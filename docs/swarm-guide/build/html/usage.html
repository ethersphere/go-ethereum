

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>5. Working with content &mdash; Swarm 0.3 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/sphinx_tabs/tabs.css" type="text/css" />
  <link rel="stylesheet" href="_static/sphinx_tabs/semantic-ui-2.2.10/segment.min.css" type="text/css" />
  <link rel="stylesheet" href="_static/sphinx_tabs/semantic-ui-2.2.10/menu.min.css" type="text/css" />
  <link rel="stylesheet" href="_static/sphinx_tabs/semantic-ui-2.2.10/tab.min.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="6. PSS" href="pss.html" />
    <link rel="prev" title="4. Uploading and downloading" href="up-and-download.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Swarm
          

          
          </a>

          
            
            
              <div class="version">
                0.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">2. Installation and Updates</a></li>
<li class="toctree-l1"><a class="reference internal" href="gettingstarted.html">3. Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="up-and-download.html">4. Uploading and downloading</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">5. Working with content</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#using-ens-names">5.1. Using ENS names</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview-of-ens-video">5.1.1. Overview of ENS (video)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#feeds">5.2. Feeds</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#feed-manifests">5.2.1. Feed Manifests</a></li>
<li class="toctree-l3"><a class="reference internal" href="#feeds-api">5.2.2. Feeds API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#http-api">5.2.2.1. HTTP API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#go-api">5.2.2.2. Go API</a></li>
<li class="toctree-l4"><a class="reference internal" href="#command-line">5.2.2.3. Command-Line</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#computing-feed-signatures">5.2.3. Computing Feed Signatures</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#javascript-example">5.2.3.1. JavaScript example</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#manifests">5.3. Manifests</a></li>
<li class="toctree-l2"><a class="reference internal" href="#encryption">5.4. Encryption</a></li>
<li class="toctree-l2"><a class="reference internal" href="#access-control">5.5. Access Control</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#password-protection">5.5.1. Password protection</a></li>
<li class="toctree-l3"><a class="reference internal" href="#selective-access-using-ec-keys">5.5.2. Selective access using EC keys</a></li>
<li class="toctree-l3"><a class="reference internal" href="#http-usage">5.5.3. HTTP usage</a></li>
<li class="toctree-l3"><a class="reference internal" href="#access-control-in-the-cli-example-usage">5.5.4. Access control in the CLI: example usage</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#fuse">5.6. FUSE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#installing-fuse">5.6.1. Installing FUSE</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cli-usage">5.6.2. CLI Usage</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#bzz-url-schemes">5.7. BZZ URL schemes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#bzz">5.7.1. bzz</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bzz-raw">5.7.2. bzz-raw</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bzz-list">5.7.3. bzz-list</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bzz-hash">5.7.4. bzz-hash</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bzz-immutable">5.7.5. bzz-immutable</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bzz-resource">5.7.6. bzz-resource</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pss.html">6. PSS</a></li>
<li class="toctree-l1"><a class="reference internal" href="apireference.html">7. API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="configuration.html">8. Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="architecture.html">9. Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="resources.html">10. Resources</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Swarm</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>5. Working with content</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/usage.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="working-with-content">
<h1>5. Working with content<a class="headerlink" href="#working-with-content" title="Permalink to this headline">¶</a></h1>
<p>In this chapter, we demonstrate features of Swarm related to storage and retrieval. First we discuss how to solve mutability of resources in a content addressed system using the Ethereum Name Service on the blockchain, then using Feeds in Swarm.
Then we briefly discuss how to protect your data by restricting access using encryption.
We also discuss in detail how files can be organised into collections using manifests and how this allows virtual hosting of websites. Another form of interaction with Swarm, namely mounting a Swarm manifest as a local directory using FUSE.
We conclude by summarizing the various URL schemes that provide simple HTTP endpoints for clients to interact with Swarm.</p>
<div class="section" id="using-ens-names">
<span id="ethereum-name-service"></span><h2>5.1. Using ENS names<a class="headerlink" href="#using-ens-names" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In order to <cite>resolve</cite> ENS names, your Swarm node has to be connected to an Ethereum blockchain (mainnet, or testnet). See <a class="reference external" href="./gettingstarted.html#connect-ens">Getting Started</a> for instructions. This section explains how you can register your content to your ENS name.</p>
</div>
<p><a class="reference external" href="http://ens.readthedocs.io/en/latest/introduction.html">ENS</a> is the system that Swarm uses to permit content to be referred to by a human-readable name, such as “theswarm.eth”. It operates analogously to the DNS system, translating human-readable names into machine identifiers - in this case, the Swarm hash of the content you’re referring to. By registering a name and setting it to resolve to the content hash of the root manifest of your site, users can access your site via a URL such as <code class="docutils literal notranslate"><span class="pre">bzz://theswarm.eth/</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently The <cite>bzz</cite> scheme is not supported in major browsers such as Chrome, Firefox or Safari. If you want to access the <cite>bzz</cite> scheme through these browsers, currently you have to either use an HTTP gateway, such as <a class="reference external" href="https://swarm-gateways.net/bzz:/theswarm.eth/">https://swarm-gateways.net/bzz:/theswarm.eth/</a> or use a browser which supports the <cite>bzz</cite> scheme, such as Mist &lt;<a class="reference external" href="https://github.com/ethereum/mist">https://github.com/ethereum/mist</a>&gt;.</p>
</div>
<p>Suppose we upload a directory to Swarm containing (among other things) the file <code class="docutils literal notranslate"><span class="pre">example.pdf</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ swarm --recursive up /path/to/dir
&gt;2477cc8584cc61091b5cc084cdcdb45bf3c6210c263b0143f030cf7d750e894d
</pre></div>
</div>
<p>If we register the root hash as the <code class="docutils literal notranslate"><span class="pre">content</span></code> for <code class="docutils literal notranslate"><span class="pre">theswarm.eth</span></code>, then we can access the pdf at</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>bzz://theswarm.eth/example.pdf
</pre></div>
</div>
<p>if we are using a Swarm-enabled browser, or at</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>http://localhost:8500/bzz:/theswarm.eth/example.pdf
</pre></div>
</div>
<p>via a local gateway. We will get served the same content as with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>http://localhost:8500/bzz:/2477cc8584cc61091b5cc084cdcdb45bf3c6210c263b0143f030cf7d750e894d/example.pdf
</pre></div>
</div>
<p>Please refer to the <a class="reference external" href="http://ens.readthedocs.io/en/latest/introduction.html">official ENS documentation</a> for the full details on how to register content hashes to ENS.</p>
<p>In short, the steps you must take are:</p>
<ol class="arabic simple">
<li>Register an ENS name.</li>
<li>Associate a resolver with that name.</li>
<li>Register the Swarm hash with the resolver as the <code class="docutils literal notranslate"><span class="pre">content</span></code>.</li>
</ol>
<p>We recommend using <a class="reference external" href="https://manager.ens.domains/">https://manager.ens.domains/</a>. This will make it easy for you to:</p>
<ul class="simple">
<li>Associate the default resolver with your name</li>
<li>Register a Swarm hash.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When you register a Swarm hash with <a class="reference external" href="https://manager.ens.domains/">https://manager.ens.domains/</a> you MUST prefix the hash with 0x. For example 0x2477cc8584cc61091b5cc084cdcdb45bf3c6210c263b0143f030cf7d750e894d</p>
</div>
<div class="section" id="overview-of-ens-video">
<h3>5.1.1. Overview of ENS (video)<a class="headerlink" href="#overview-of-ens-video" title="Permalink to this headline">¶</a></h3>
<p>Nick Johnson on the Ethereum Name System</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/pLDDbCZXvTE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div>
</div>
<div class="section" id="feeds">
<h2>5.2. Feeds<a class="headerlink" href="#feeds" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Feeds, previously known as <em>Mutable Resource Updates</em>, is an experimental feature, available since Swarm POC3. It is under active development, so expect things to change.</p>
</div>
<p>Since Swarm hashes are content addressed, changes to data will constantly result in changing hashes. Swarm Feeds provide a way to easily overcome this problem and provide a single, persistent, identifier to follow sequential data.</p>
<p>The usual way of keeping the same pointer to changing data is using the Ethereum Name Service (ENS). However, since ENS is an on-chain feature, it might not be suitable for each use case since:</p>
<ol class="arabic simple">
<li>Every update to an ENS resolver will cost gas to execute</li>
<li>It is not be possible to change the data faster than the rate that new blocks are mined</li>
<li>ENS resolution requires your node to be synced to the blockchain</li>
</ol>
<p>Swarm Feeds provide a way to have a persistent identifier for changing data without having to use ENS. It is named Feeds for its similarity with a news feed.</p>
<p>If you are using <em>Feeds</em> in conjunction with an ENS resolver contract, only one initial transaction to register the “Feed manifest address” will be necessary. This key will resolve to the latest version of the Feed (updating the Feed will not change the key).</p>
<p>You can think of a Feed as a user’s Twitter account, where he/she posts updates about a particular Topic. In fact, the Feed object is simply defined as:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">Feed</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Topic</span> <span class="nx">Topic</span>
  <span class="nx">User</span>  <span class="nx">common</span><span class="p">.</span><span class="nx">Address</span>
<span class="p">}</span>
</pre></div>
</div>
<p>That is, a specific user posting updates about a specific Topic.</p>
<p>Users can post to any topic. If you know the user’s address and agree on a particular Topic, you can then effectively “follow” that user’s Feed.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p>How you build the Topic is entirely up to your application. You could calculate a hash of something and use that, the recommendation
is that it should be easy to derive out of information that is accesible to other users.</p>
<p class="last">For convenience, <code class="docutils literal notranslate"><span class="pre">feed.NewTopic()</span></code> provides a way to “merge” a byte array with a string in order to build a Feed Topic out of both.
This is used at the API level to create the illusion of subtopics. This way of building topics allows using a random byte array (for example the hash of a photo)
and merge it with a human-readable string such as “comments” in order to create a Topic that could represent the comments about that particular photo.
This way, when you see a picture in a website you could immediately build a Topic out of it and see if some user posted comments about that photo.</p>
</div>
<p>Feeds are not created, only updated. If a particular Feed (user, topic combination) has never posted to, trying to fetch updates will yield nothing.</p>
<div class="section" id="feed-manifests">
<h3>5.2.1. Feed Manifests<a class="headerlink" href="#feed-manifests" title="Permalink to this headline">¶</a></h3>
<p>A Feed Manifest is simply a JSON object that contains the <code class="docutils literal notranslate"><span class="pre">Topic</span></code> and <code class="docutils literal notranslate"><span class="pre">User</span></code> of a particular Feed (i.e., a serialized <code class="docutils literal notranslate"><span class="pre">Feed</span></code> object). Uploading this JSON object to Swarm in the regular way will return the immutable hash of this object. We can then store this immutable hash in an ENS Resolver so that we can have a ENS domain that “follows” the Feed described in the manifest.</p>
</div>
<div class="section" id="feeds-api">
<h3>5.2.2. Feeds API<a class="headerlink" href="#feeds-api" title="Permalink to this headline">¶</a></h3>
<p>There  are 3 different ways of interacting with <em>Feeds</em> : HTTP API, CLI and Golang API.</p>
<div class="section" id="http-api">
<h4>5.2.2.1. HTTP API<a class="headerlink" href="#http-api" title="Permalink to this headline">¶</a></h4>
<div class="section" id="posting-to-a-feed">
<h5>5.2.2.1.1. Posting to a Feed<a class="headerlink" href="#posting-to-a-feed" title="Permalink to this headline">¶</a></h5>
<p>Since Feed updates need to be signed, and an update has some correlation with a previous update, it is necessary to retrieve first the Feed’s current status. Thus, the first step to post an update will be to retrieve this current status in a ready-to-sign template:</p>
<ol class="arabic simple">
<li>Get Feed template</li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">GET</span> <span class="pre">/bzz-feed:/?topic=&lt;TOPIC&gt;&amp;user=&lt;USER&gt;&amp;meta=1</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">GET</span> <span class="pre">/bzz-feed:/&lt;MANIFEST</span> <span class="pre">OR</span> <span class="pre">ENS</span> <span class="pre">NAME&gt;/?meta=1</span></code></p>
<dl class="docutils">
<dt>Where:</dt>
<dd><ul class="first last simple">
<li><code class="docutils literal notranslate"><span class="pre">user</span></code>: Ethereum address of the user who publishes the Feed</li>
<li><code class="docutils literal notranslate"><span class="pre">topic</span></code>: Feed topic, encoded as a hex string. Topic is an arbitrary 32-byte string (64 hex chars)</li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>If <code class="docutils literal notranslate"><span class="pre">topic</span></code> is omitted, it is assumed to be zero, 0x000…</li>
<li>if <code class="docutils literal notranslate"><span class="pre">name=&lt;name&gt;</span></code> (optional) is provided, a subtopic is composed with that name</li>
<li>A common use is to omit topic and just use <code class="docutils literal notranslate"><span class="pre">name</span></code>, allowing for human-readable topics</li>
</ul>
</div>
<p>You will receive a JSON like the below:</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="s2">&quot;feed&quot;</span><span class="o">:</span> <span class="p">{</span>
    <span class="s2">&quot;topic&quot;</span><span class="o">:</span> <span class="s2">&quot;0x6a61766900000000000000000000000000000000000000000000000000000000&quot;</span><span class="p">,</span>
    <span class="s2">&quot;user&quot;</span><span class="o">:</span> <span class="s2">&quot;0xdfa2db618eacbfe84e94a71dda2492240993c45b&quot;</span>
  <span class="p">},</span>
  <span class="s2">&quot;epoch&quot;</span><span class="o">:</span> <span class="p">{</span>
    <span class="s2">&quot;level&quot;</span><span class="o">:</span> <span class="mi">16</span><span class="p">,</span>
    <span class="s2">&quot;time&quot;</span><span class="o">:</span> <span class="mi">1534237239</span>
  <span class="p">}</span>
  <span class="s2">&quot;protocolVersion&quot;</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li>Post the update</li>
</ol>
<p>Extract the fields out of the JSON and build a query string as below:</p>
<p><code class="docutils literal notranslate"><span class="pre">POST</span> <span class="pre">/bzz-feed:/?topic=&lt;TOPIC&gt;&amp;user=&lt;USER&gt;&amp;level=&lt;LEVEL&gt;&amp;time=&lt;TIME&gt;&amp;signature=&lt;SIGNATURE&gt;</span></code></p>
<dl class="docutils">
<dt>Where:</dt>
<dd><ul class="first last simple">
<li><code class="docutils literal notranslate"><span class="pre">topic</span></code>: Feed topic, as specified above</li>
<li><code class="docutils literal notranslate"><span class="pre">user</span></code>: your Ethereum address</li>
<li><code class="docutils literal notranslate"><span class="pre">level</span></code>: Suggested frequency level retrieved in the JSON above</li>
<li><code class="docutils literal notranslate"><span class="pre">time</span></code>: Suggested timestamp retrieved in the JSON above</li>
<li><code class="docutils literal notranslate"><span class="pre">protocolVersion</span></code>: Feeds protocol version. Currently <code class="docutils literal notranslate"><span class="pre">0</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">signature</span></code>: Signature, hex encoded. See below on how to calclulate the signature</li>
<li>Request posted data: binary stream with the update data</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="reading-a-feed">
<h5>5.2.2.1.2. Reading a Feed<a class="headerlink" href="#reading-a-feed" title="Permalink to this headline">¶</a></h5>
<p>To retrieve a Feed’s last update:</p>
<p><code class="docutils literal notranslate"><span class="pre">GET</span> <span class="pre">/bzz-feed:/?topic=&lt;TOPIC&gt;&amp;user=&lt;USER&gt;</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">GET</span> <span class="pre">/bzz-feed:/&lt;MANIFEST</span> <span class="pre">OR</span> <span class="pre">ENS</span> <span class="pre">NAME&gt;</span></code></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>Again, if <code class="docutils literal notranslate"><span class="pre">topic</span></code> is omitted, it is assumed to be zero, 0x000…</li>
<li>If <code class="docutils literal notranslate"><span class="pre">name=&lt;name&gt;</span></code> is provided, a subtopic is composed with that name</li>
<li>A common use is to omit <code class="docutils literal notranslate"><span class="pre">topic</span></code> and just use <code class="docutils literal notranslate"><span class="pre">name</span></code>, allowing for human-readable topics, for example:
<code class="docutils literal notranslate"><span class="pre">GET</span> <span class="pre">/bzz-feed:/?name=profile-picture&amp;user=&lt;USER&gt;</span></code></li>
</ul>
</div>
<p>To get a previous update:</p>
<p>Add an addtional <code class="docutils literal notranslate"><span class="pre">time</span></code> parameter. The last update before that <code class="docutils literal notranslate"><span class="pre">time</span></code> (unix time) will be looked up.</p>
<p><code class="docutils literal notranslate"><span class="pre">GET</span> <span class="pre">/bzz-feed:/?topic=&lt;TOPIC&gt;&amp;user=&lt;USER&gt;&amp;time=&lt;T&gt;</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">GET</span> <span class="pre">/bzz-feed:/&lt;MANIFEST</span> <span class="pre">OR</span> <span class="pre">ENS</span> <span class="pre">NAME&gt;?time=&lt;T&gt;</span></code></p>
</div>
<div class="section" id="creating-a-feed-manifest">
<h5>5.2.2.1.3. Creating a Feed Manifest<a class="headerlink" href="#creating-a-feed-manifest" title="Permalink to this headline">¶</a></h5>
<p>To create a <code class="docutils literal notranslate"><span class="pre">Feed</span> <span class="pre">manifest</span></code> using the HTTP API:</p>
<p><code class="docutils literal notranslate"><span class="pre">POST</span> <span class="pre">/bzz-feed:/?topic=&lt;TOPIC&gt;&amp;user=&lt;USER&gt;&amp;manifest=1.</span></code> With an empty body.</p>
<p>This will create a manifest referencing the provided Feed.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This API call will be deprecated in the near future.</p>
</div>
</div>
</div>
<div class="section" id="go-api">
<h4>5.2.2.2. Go API<a class="headerlink" href="#go-api" title="Permalink to this headline">¶</a></h4>
<div class="section" id="query-object">
<h5>5.2.2.2.1. Query object<a class="headerlink" href="#query-object" title="Permalink to this headline">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">Query</span></code> object allows you to build a query to browse a particular <code class="docutils literal notranslate"><span class="pre">Feed</span></code>.</p>
<p>The default <code class="docutils literal notranslate"><span class="pre">Query</span></code>, obtained with <code class="docutils literal notranslate"><span class="pre">feed.NewQueryLatest()</span></code> will build a <code class="docutils literal notranslate"><span class="pre">Query</span></code> that retrieves the latest update of the given <code class="docutils literal notranslate"><span class="pre">Feed</span></code>.</p>
<p>You can also use <code class="docutils literal notranslate"><span class="pre">feed.NewQuery()</span></code> instead, if you want to build a <code class="docutils literal notranslate"><span class="pre">Query</span></code> to look up an update before a certain date.</p>
<p>Advanced usage of <code class="docutils literal notranslate"><span class="pre">Query</span></code> includes hinting the lookup algorithm for faster lookups. The default hint <code class="docutils literal notranslate"><span class="pre">lookup.NoClue</span></code> will have your node track Feeds you query frequently and handle hints automatically.</p>
</div>
<div class="section" id="request-object">
<h5>5.2.2.2.2. Request object<a class="headerlink" href="#request-object" title="Permalink to this headline">¶</a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">Request</span></code> object makes it easy to construct and sign a request to Swarm to update a particular Feed. It contains methods to sign and add data. We can  manually build the <code class="docutils literal notranslate"><span class="pre">Request</span></code> object, or fetch a valid “template” to use for the update.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">Request</span></code> can also be serialized to JSON in case you need your application to delegate signatures, such as having a browser sign a Feed update request.</p>
</div>
<div class="section" id="id1">
<h5>5.2.2.2.3. Posting to a Feed<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h5>
<ol class="arabic simple">
<li>Retrieve a <code class="docutils literal notranslate"><span class="pre">Request</span></code> object or build one from scratch. To retrieve a ready-to-sign one:</li>
</ol>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Client</span><span class="p">)</span> <span class="nx">GetFeedRequest</span><span class="p">(</span><span class="nx">query</span> <span class="o">*</span><span class="nx">feed</span><span class="p">.</span><span class="nx">Query</span><span class="p">,</span> <span class="nx">manifestAddressOrDomain</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">feed</span><span class="p">.</span><span class="nx">Request</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li>Use <code class="docutils literal notranslate"><span class="pre">Request.SetData()</span></code> and <code class="docutils literal notranslate"><span class="pre">Request.Sign()</span></code> to load the payload data into the request and sign it</li>
<li>Call <code class="docutils literal notranslate"><span class="pre">UpdateFeed()</span></code> with the filled <code class="docutils literal notranslate"><span class="pre">Request</span></code>:</li>
</ol>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Client</span><span class="p">)</span> <span class="nx">UpdateFeed</span><span class="p">(</span><span class="nx">request</span> <span class="o">*</span><span class="nx">feed</span><span class="p">.</span><span class="nx">Request</span><span class="p">,</span> <span class="nx">createManifest</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h5>5.2.2.2.4. Reading a Feed<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h5>
<p>To retrieve a Feed update, use <cite>client.QueryFeed()</cite>. <code class="docutils literal notranslate"><span class="pre">QueryFeed</span></code> returns a byte stream with the raw content of the Feed update.</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Client</span><span class="p">)</span> <span class="nx">QueryFeed</span><span class="p">(</span><span class="nx">query</span> <span class="o">*</span><span class="nx">feed</span><span class="p">.</span><span class="nx">Query</span><span class="p">,</span> <span class="nx">manifestAddressOrDomain</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">io</span><span class="p">.</span><span class="nx">ReadCloser</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">manifestAddressOrDomain</span></code> is the address you obtained in <code class="docutils literal notranslate"><span class="pre">CreateFeedWithManifest</span></code> or an <code class="docutils literal notranslate"><span class="pre">ENS</span></code> domain whose Resolver
points to that address.
<code class="docutils literal notranslate"><span class="pre">query</span></code> is a Query object, as defined above.</p>
<p>You only need to provide either <code class="docutils literal notranslate"><span class="pre">manifestAddressOrDomain</span></code> or <code class="docutils literal notranslate"><span class="pre">Query</span></code> to <code class="docutils literal notranslate"><span class="pre">QueryFeed()</span></code>. Set to <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">nil</span></code> respectively.</p>
</div>
<div class="section" id="id3">
<h5>5.2.2.2.5. Creating a Feed Manifest<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h5>
<p>Swarm client (package swarm/api/client) has the following method:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Client</span><span class="p">)</span> <span class="nx">CreateFeedWithManifest</span><span class="p">(</span><span class="nx">request</span> <span class="o">*</span><span class="nx">feed</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">CreateFeedWithManifest</span></code> uses the <code class="docutils literal notranslate"><span class="pre">request</span></code> parameter to set and create a  <code class="docutils literal notranslate"><span class="pre">Feed</span> <span class="pre">manifest</span></code>.</p>
<p>Returns the resulting <code class="docutils literal notranslate"><span class="pre">Feed</span> <span class="pre">manifest</span> <span class="pre">address</span></code> that you can set in an ENS Resolver (setContent) or reference future updates using <code class="docutils literal notranslate"><span class="pre">Client.UpdateFeed()</span></code></p>
</div>
<div class="section" id="example-go-code">
<h5>5.2.2.2.6. Example Go code<a class="headerlink" href="#example-go-code" title="Permalink to this headline">¶</a></h5>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Build a `Feed` object to track a particular user&#39;s updates</span>
<span class="nx">f</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">feed</span><span class="p">.</span><span class="nx">Feed</span><span class="p">)</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">User</span> <span class="p">=</span> <span class="nx">signer</span><span class="p">.</span><span class="nx">Address</span><span class="p">()</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">Topic</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">feed</span><span class="p">.</span><span class="nx">NewTopic</span><span class="p">(</span><span class="s">&quot;weather&quot;</span><span class="p">,</span><span class="kc">nil</span><span class="p">)</span>

<span class="c1">// Build a `Query` to retrieve a current Request for this feed</span>
<span class="nx">query</span> <span class="o">:=</span> <span class="nx">feeds</span><span class="p">.</span><span class="nx">NewQueryLatest</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">f</span><span class="p">,</span> <span class="nx">lookup</span><span class="p">.</span><span class="nx">NoClue</span><span class="p">)</span>

<span class="c1">// Retrieve a ready-to-sign request using our query</span>
<span class="c1">// (queries can be reused)</span>
<span class="nx">request</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nx">GetFeedRequest</span><span class="p">(</span><span class="nx">query</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">utils</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;Error retrieving feed status: %s&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nx">Error</span><span class="p">())</span>
<span class="p">}</span>

<span class="c1">// set the new data</span>
<span class="nx">request</span><span class="p">.</span><span class="nx">SetData</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;Weather looks bright and sunny today, we should merge this PR and go out enjoy&quot;</span><span class="p">))</span>

<span class="c1">// sign update</span>
<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">request</span><span class="p">.</span><span class="nx">Sign</span><span class="p">(</span><span class="nx">signer</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">utils</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;Error signing feed update: %s&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nx">Error</span><span class="p">())</span>
<span class="p">}</span>

<span class="c1">// post update</span>
<span class="nx">err</span> <span class="p">=</span> <span class="nx">client</span><span class="p">.</span><span class="nx">UpdateFeed</span><span class="p">(</span><span class="nx">request</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">utils</span><span class="p">.</span><span class="nx">Fatalf</span><span class="p">(</span><span class="s">&quot;Error updating feed: %s&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nx">Error</span><span class="p">())</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="command-line">
<h4>5.2.2.3. Command-Line<a class="headerlink" href="#command-line" title="Permalink to this headline">¶</a></h4>
<p>The CLI API allows us to go through how Feeds work using practical examples. You can look up CL usage by typing <code class="docutils literal notranslate"><span class="pre">swarm</span> <span class="pre">feed</span></code> into your CLI.</p>
<p>In the CLI examples, we will create and update feeds using the bzzapi on a running local Swarm node that listens by default on port 8500.</p>
<div class="section" id="id4">
<h5>5.2.2.3.1. Creating a Feed Manifest<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h5>
<p>The Swarm CLI allows creating Feed Manifests directly from the console.</p>
<p><code class="docutils literal notranslate"><span class="pre">swarm</span> <span class="pre">feed</span> <span class="pre">create</span></code> is defined as a command to create and publish a <code class="docutils literal notranslate"><span class="pre">Feed</span> <span class="pre">manifest</span></code>.</p>
<dl class="docutils">
<dt>The feed topic can be built in the following ways:</dt>
<dd><ul class="first last simple">
<li>use <code class="docutils literal notranslate"><span class="pre">--topic</span></code> to set the topic to an arbitrary binary hex string.</li>
<li><dl class="first docutils">
<dt>use <code class="docutils literal notranslate"><span class="pre">--name</span></code> to set the topic to a human-readable name.</dt>
<dd>For example, <code class="docutils literal notranslate"><span class="pre">--name</span></code> could be set to “profile-picture”, meaning this feed allows to get this user’s current profile picture.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>use both <code class="docutils literal notranslate"><span class="pre">--topic</span></code> and <code class="docutils literal notranslate"><span class="pre">--name</span></code> to create named subtopics.</dt>
<dd>For example, <cite>–topic</cite> could be set to an Ethereum contract address and <code class="docutils literal notranslate"><span class="pre">--name</span></code> could be set to “comments”, meaning this feed tracks a discussion about that contract.</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>The <code class="docutils literal notranslate"><span class="pre">--user</span></code> flag allows to have this manifest refer to a user other than yourself. If not specified, it will then default to your local account (<code class="docutils literal notranslate"><span class="pre">--bzzaccount</span></code>).</p>
<p>If you don’t specify a name or a topic, the topic will be set to <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">hex</span></code> and name will be set to your username.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ swarm --bzzapi http://localhost:8500 feed create --name test
</pre></div>
</div>
<p>creates a feed named “test”. This is equivalent to the HTTP API way of</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ swarm --bzzapi http://localhost:8500 feed create --topic 0x74657374
</pre></div>
</div>
<p>since <code class="docutils literal notranslate"><span class="pre">test</span> <span class="pre">string</span> <span class="pre">==</span> <span class="pre">0x74657374</span> <span class="pre">hex</span></code>. Name and topic are interchangeable, as long as you don’t specify both.</p>
<p><code class="docutils literal notranslate"><span class="pre">feed</span> <span class="pre">create</span></code> will return the <strong>feed manifest</strong>.</p>
<p>You can also use <code class="docutils literal notranslate"><span class="pre">curl</span></code> in the HTTP API, but, here, you have to explicitly define the user (which, in this case, is your account) and the manifest.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ curl -XPOST -d &#39;name=test&amp;user=&lt;your account&gt;&amp;manifest=1&#39; http://localhost:8500/bzz-Feed:/
</pre></div>
</div>
<p>is equivalent to</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ curl -XPOST -d &#39;topic=0x74657374&amp;user=&lt;your account&gt;&amp;manifest=1&#39; http://localhost:8500/bzz-Feed:/
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h5>5.2.2.3.2. Posting to a Feed<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h5>
<p>To update a Feed with the CLI, use <code class="docutils literal notranslate"><span class="pre">feed</span> <span class="pre">update</span></code>. The <strong>update</strong> argument has to be in <code class="docutils literal notranslate"><span class="pre">hex</span></code>. If you want to update your <em>test</em> feed with the update <em>hello</em>, you can refer to it by name:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ swarm --bzzapi http://localhost:8500 feed update --name test 0x68656c6c6f203
</pre></div>
</div>
<p>You can also refer to it by topic,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ swarm --bzzapi http://localhost:8500 feed update --topic 0x74657374 0x68656c6c6f203
</pre></div>
</div>
<p>or manifest.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ swarm --bzzapi http://localhost:8500 feed update --manifest &lt;manifest hash&gt; 0x68656c6c6f203
</pre></div>
</div>
</div>
<div class="section" id="reading-feed-status">
<h5>5.2.2.3.3. Reading Feed status<a class="headerlink" href="#reading-feed-status" title="Permalink to this headline">¶</a></h5>
<p>You can read the feed object using <code class="docutils literal notranslate"><span class="pre">feed</span> <span class="pre">info</span></code>. Again, you can use the feed name, the topic, or the manifest hash. Below, we use the name.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ swarm --bzzapi http://localhost:8500 feed info --name test
</pre></div>
</div>
</div>
<div class="section" id="reading-feed-updates">
<h5>5.2.2.3.4. Reading Feed Updates<a class="headerlink" href="#reading-feed-updates" title="Permalink to this headline">¶</a></h5>
<p>Although the Swarm CLI doesn’t have the functionality to retrieve feed updates, we can use <code class="docutils literal notranslate"><span class="pre">curl</span></code> and the HTTP api to retrieve them. Again, you can use the feed name, topic, or manifest hash. To return the update <code class="docutils literal notranslate"><span class="pre">hello</span></code> for your <code class="docutils literal notranslate"><span class="pre">test</span></code> feed, do this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ curl &#39;http://localhost:8500/bzz-feed:/?user=&lt;your address&gt;&amp;name=test&#39;
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="computing-feed-signatures">
<h3>5.2.3. Computing Feed Signatures<a class="headerlink" href="#computing-feed-signatures" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li>computing the digest:</li>
</ol>
<dl class="docutils">
<dt>The digest is computed concatenating the following:</dt>
<dd><ul class="first last simple">
<li>1-byte protocol version (currently 0)</li>
<li>7-bytes padding, set to 0</li>
<li>32-bytes topic</li>
<li>20-bytes user address</li>
<li>7-bytes time, little endian</li>
<li>1-byte level</li>
<li>payload data (variable length)</li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li>Take the SHA3 hash of the above digest</li>
<li>Compute the ECDSA signature of the hash</li>
<li>Convert to hex string and put in the <code class="docutils literal notranslate"><span class="pre">signature</span></code> field above</li>
</ol>
<div class="section" id="javascript-example">
<h4>5.2.3.1. JavaScript example<a class="headerlink" href="#javascript-example" title="Permalink to this headline">¶</a></h4>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">web3</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;web3&quot;</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">module</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">digest</span><span class="o">:</span> <span class="nx">feedUpdateDigest</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">topicLength</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">userLength</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">timeLength</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">levelLength</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">headerLength</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">updateMinLength</span> <span class="o">=</span> <span class="nx">topicLength</span> <span class="o">+</span> <span class="nx">userLength</span> <span class="o">+</span> <span class="nx">timeLength</span> <span class="o">+</span> <span class="nx">levelLength</span> <span class="o">+</span> <span class="nx">headerLength</span><span class="p">;</span>




<span class="kd">function</span> <span class="nx">feedUpdateDigest</span><span class="p">(</span><span class="nx">request</span> <span class="cm">/*request*/</span><span class="p">,</span> <span class="nx">data</span> <span class="cm">/*UInt8Array*/</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">topicBytes</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">userBytes</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">protocolVersion</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="nx">protocolVersion</span> <span class="o">=</span> <span class="nx">request</span><span class="p">.</span><span class="nx">protocolVersion</span>

  <span class="k">try</span> <span class="p">{</span>
    <span class="nx">topicBytes</span> <span class="o">=</span> <span class="nx">web3</span><span class="p">.</span><span class="nx">utils</span><span class="p">.</span><span class="nx">hexToBytes</span><span class="p">(</span><span class="nx">request</span><span class="p">.</span><span class="nx">feed</span><span class="p">.</span><span class="nx">topic</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="s2">&quot;topicBytes: &quot;</span> <span class="o">+</span> <span class="nx">err</span><span class="p">);</span>
    <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">try</span> <span class="p">{</span>
    <span class="nx">userBytes</span> <span class="o">=</span> <span class="nx">web3</span><span class="p">.</span><span class="nx">utils</span><span class="p">.</span><span class="nx">hexToBytes</span><span class="p">(</span><span class="nx">request</span><span class="p">.</span><span class="nx">feed</span><span class="p">.</span><span class="nx">user</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="s2">&quot;topicBytes: &quot;</span> <span class="o">+</span> <span class="nx">err</span><span class="p">);</span>
    <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">var</span> <span class="nx">buf</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ArrayBuffer</span><span class="p">(</span><span class="nx">updateMinLength</span> <span class="o">+</span> <span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">view</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DataView</span><span class="p">(</span><span class="nx">buf</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">cursor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="nx">view</span><span class="p">.</span><span class="nx">setUint8</span><span class="p">(</span><span class="nx">cursor</span><span class="p">,</span> <span class="nx">protocolVersion</span><span class="p">)</span> <span class="c1">// first byte is protocol version.</span>
    <span class="nx">cursor</span><span class="o">+=</span><span class="nx">headerLength</span><span class="p">;</span> <span class="c1">// leave the next 7 bytes (padding) set to zero</span>

  <span class="nx">topicBytes</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">view</span><span class="p">.</span><span class="nx">setUint8</span><span class="p">(</span><span class="nx">cursor</span><span class="p">,</span> <span class="nx">v</span><span class="p">);</span>
    <span class="nx">cursor</span><span class="o">++</span><span class="p">;</span>
  <span class="p">});</span>

  <span class="nx">userBytes</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">view</span><span class="p">.</span><span class="nx">setUint8</span><span class="p">(</span><span class="nx">cursor</span><span class="p">,</span> <span class="nx">v</span><span class="p">);</span>
    <span class="nx">cursor</span><span class="o">++</span><span class="p">;</span>
  <span class="p">});</span>

  <span class="c1">// time is little-endian</span>
  <span class="nx">view</span><span class="p">.</span><span class="nx">setUint32</span><span class="p">(</span><span class="nx">cursor</span><span class="p">,</span> <span class="nx">request</span><span class="p">.</span><span class="nx">epoch</span><span class="p">.</span><span class="nx">time</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
  <span class="nx">cursor</span> <span class="o">+=</span> <span class="mi">7</span><span class="p">;</span>

  <span class="nx">view</span><span class="p">.</span><span class="nx">setUint8</span><span class="p">(</span><span class="nx">cursor</span><span class="p">,</span> <span class="nx">request</span><span class="p">.</span><span class="nx">epoch</span><span class="p">.</span><span class="nx">level</span><span class="p">);</span>
  <span class="nx">cursor</span><span class="o">++</span><span class="p">;</span>

  <span class="nx">data</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">view</span><span class="p">.</span><span class="nx">setUint8</span><span class="p">(</span><span class="nx">cursor</span><span class="p">,</span> <span class="nx">v</span><span class="p">);</span>
    <span class="nx">cursor</span><span class="o">++</span><span class="p">;</span>
    <span class="p">});</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">web3</span><span class="p">.</span><span class="nx">utils</span><span class="p">.</span><span class="nx">bytesToHex</span><span class="p">(</span><span class="k">new</span> <span class="nx">Uint8Array</span><span class="p">(</span><span class="nx">buf</span><span class="p">)))</span>

  <span class="k">return</span> <span class="nx">web3</span><span class="p">.</span><span class="nx">utils</span><span class="p">.</span><span class="nx">sha3</span><span class="p">(</span><span class="nx">web3</span><span class="p">.</span><span class="nx">utils</span><span class="p">.</span><span class="nx">bytesToHex</span><span class="p">(</span><span class="k">new</span> <span class="nx">Uint8Array</span><span class="p">(</span><span class="nx">buf</span><span class="p">)));</span>
<span class="p">}</span>

<span class="c1">// data payload</span>
<span class="nx">data</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Uint8Array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">154</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">165</span><span class="p">,</span><span class="mi">62</span><span class="p">])</span>

<span class="c1">// request template, obtained calling http://localhost:8500/bzz-feed:/?user=&lt;0xUSER&gt;&amp;topic=&lt;0xTOPIC&gt;&amp;meta=1</span>
<span class="nx">request</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;feed&quot;</span><span class="o">:</span><span class="p">{</span><span class="s2">&quot;topic&quot;</span><span class="o">:</span><span class="s2">&quot;0x1234123412341234123412341234123412341234123412341234123412341234&quot;</span><span class="p">,</span><span class="s2">&quot;user&quot;</span><span class="o">:</span><span class="s2">&quot;0xabcdefabcdefabcdefabcdefabcdefabcdefabcd&quot;</span><span class="p">},</span><span class="s2">&quot;epoch&quot;</span><span class="o">:</span><span class="p">{</span><span class="s2">&quot;time&quot;</span><span class="o">:</span><span class="mi">1538650124</span><span class="p">,</span><span class="s2">&quot;level&quot;</span><span class="o">:</span><span class="mi">25</span><span class="p">},</span><span class="s2">&quot;protocolVersion&quot;</span><span class="o">:</span><span class="mi">0</span><span class="p">}</span>

<span class="c1">// obtain digest</span>
<span class="nx">digest</span> <span class="o">=</span> <span class="nx">feedUpdateDigest</span><span class="p">(</span><span class="nx">request</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">digest</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="manifests">
<h2>5.3. Manifests<a class="headerlink" href="#manifests" title="Permalink to this headline">¶</a></h2>
<p id="swarm-manifest">In general manifests declare a list of strings associated with Swarm hashes. A manifest matches to exactly one hash, and it consists of a list of entries declaring the content which can be retrieved through that hash. This is demonstrated by the following example:</p>
<p>Let’s create a directory containing the two orange papers and an html index file listing the two pdf documents.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ls -1 orange-papers/
index.html
smash.pdf
sw^3.pdf

$ cat orange-papers/index.html
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;a href=&quot;./sw^3.pdf&quot;&gt;Viktor Trón, Aron Fischer, Dániel Nagy A and Zsolt Felföldi, Nick Johnson: swap, swear and swindle: incentive system for swarm.&lt;/a&gt;  May 2016
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a href=&quot;./smash.pdf&quot;&gt;Viktor Trón, Aron Fischer, Nick Johnson: smash-proof: auditable storage for swarm secured by masked audit secret hash.&lt;/a&gt; May 2016
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre></div>
</div>
<p>We now use the <code class="docutils literal notranslate"><span class="pre">swarm</span> <span class="pre">up</span></code> command to upload the directory to Swarm to create a mini virtual site.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In this example we are using the public gateway through the <cite>bzz-api</cite> option in order to upload. The examples below assume a node running on localhost to access content. Make sure to run a local node to reproduce these examples.</p>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ swarm --recursive --defaultpath orange-papers/index.html --bzzapi http://swarm-gateways.net/ up orange-papers/ 2&gt; up.log
&gt; 2477cc8584cc61091b5cc084cdcdb45bf3c6210c263b0143f030cf7d750e894d
</pre></div>
</div>
<p>The returned hash is the hash of the manifest for the uploaded content (the orange-papers directory):</p>
<p>We now can get the manifest itself directly (instead of the files they refer to) by using the bzz-raw protocol <code class="docutils literal notranslate"><span class="pre">bzz-raw</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ wget -O- &quot;http://localhost:8500/bzz-raw:/2477cc8584cc61091b5cc084cdcdb45bf3c6210c263b0143f030cf7d750e894d&quot;

&gt; {
  &quot;entries&quot;: [
    {
      &quot;hash&quot;: &quot;4b3a73e43ae5481960a5296a08aaae9cf466c9d5427e1eaa3b15f600373a048d&quot;,
      &quot;contentType&quot;: &quot;text/html; charset=utf-8&quot;
    },
    {
      &quot;hash&quot;: &quot;4b3a73e43ae5481960a5296a08aaae9cf466c9d5427e1eaa3b15f600373a048d&quot;,
      &quot;contentType&quot;: &quot;text/html; charset=utf-8&quot;,
      &quot;path&quot;: &quot;index.html&quot;
    },
    {
      &quot;hash&quot;: &quot;69b0a42a93825ac0407a8b0f47ccdd7655c569e80e92f3e9c63c28645df3e039&quot;,
      &quot;contentType&quot;: &quot;application/pdf&quot;,
      &quot;path&quot;: &quot;smash.pdf&quot;
    },
    {
      &quot;hash&quot;: &quot;6a18222637cafb4ce692fa11df886a03e6d5e63432c53cbf7846970aa3e6fdf5&quot;,
      &quot;contentType&quot;: &quot;application/pdf&quot;,
      &quot;path&quot;: &quot;sw^3.pdf&quot;
    }
  ]
}
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">macOS users can install wget via homebrew (or use curl).</p>
</div>
<p>Manifests contain content_type information for the hashes they reference. In other contexts, where content_type is not supplied or, when you suspect the information is wrong, it is possible to specify the content_type manually in the search query. For example, the manifest itself should be <cite>text/plain</cite>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>http://localhost:8500/bzz-raw:/2477cc8584cc61091b5cc084cdcdb45bf3c6210c263b0143f030cf7d750e894d?content_type=&quot;text/plain&quot;
</pre></div>
</div>
<p>Now you can also check that the manifest hash matches the content (in fact, Swarm does this for you):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ wget -O- http://localhost:8500/bzz-raw:/2477cc8584cc61091b5cc084cdcdb45bf3c6210c263b0143f030cf7d750e894d?content_type=&quot;text/plain&quot; &gt; manifest.json

$ swarm hash manifest.json
&gt; 2477cc8584cc61091b5cc084cdcdb45bf3c6210c263b0143f030cf7d750e894d
</pre></div>
</div>
<p>A useful feature of manifests is that we can match paths with URLs.
In some sense this makes the manifest a routing table and so the manifest acts as if it was a host.</p>
<p>More concretely, continuing in our example, when we request:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>GET http://localhost:8500/bzz:/2477cc8584cc61091b5cc084cdcdb45bf3c6210c263b0143f030cf7d750e894d/sw^3.pdf
</pre></div>
</div>
<p>Swarm first retrieves the document matching the manifest above. The url path <code class="docutils literal notranslate"><span class="pre">sw^3</span></code> is then matched against the entries. In this case a perfect match is found and the document at 6a182226… is served as a pdf.</p>
<p>As you can see the manifest contains 4 entries, although our directory contained only 3. The extra entry is there because of the <code class="docutils literal notranslate"><span class="pre">--defaultpath</span> <span class="pre">orange-papers/index.html</span></code> option to <code class="docutils literal notranslate"><span class="pre">swarm</span> <span class="pre">up</span></code>, which associates the empty path with the file you give as its argument. This makes it possible to have a default page served when the url path is empty.
This feature essentially implements the most common webserver rewrite rules used to set the landing page of a site served when the url only contains the domain. So when you request</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>GET http://localhost:8500/bzz:/2477cc8584cc61091b5cc084cdcdb45bf3c6210c263b0143f030cf7d750e894d/
</pre></div>
</div>
<p>you get served the index page (with content type <code class="docutils literal notranslate"><span class="pre">text/html</span></code>) at <code class="docutils literal notranslate"><span class="pre">4b3a73e43ae5481960a5296a08aaae9cf466c9d5427e1eaa3b15f600373a048d</span></code>.</p>
<p>Swarm manifests don’t “break” like a file system. In a file system, the directory matches at the path separator (<cite>/</cite> in linux) at the end of a directory name:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-- dirname/
----subdir1/
------subdir1file.ext
------subdir2file.ext
----subdir2/
------subdir2file.ext
</pre></div>
</div>
<p>In Swarm, path matching does not happen on a given path separator, but <strong>on common prefixes</strong>. Let’s look at an example:
The current manifest for the <code class="docutils literal notranslate"><span class="pre">theswarm.eth</span></code> homepage is as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>wget -O- &quot;http://swarm-gateways.net/bzz-raw:/theswarm.eth/ &gt; manifest.json

&gt; {&quot;entries&quot;:[{&quot;hash&quot;:&quot;ee55bc6844189299a44e4c06a4b7fbb6d66c90004159c67e6c6d010663233e26&quot;,&quot;path&quot;:&quot;LICENSE&quot;,&quot;mode&quot;:420,&quot;size&quot;:1211,&quot;mod_time&quot;:&quot;2018-06-12T15:36:29Z&quot;},
            {&quot;hash&quot;:&quot;57fc80622275037baf4a620548ba82b284845b8862844c3f56825ae160051446&quot;,&quot;path&quot;:&quot;README.md&quot;,&quot;mode&quot;:420,&quot;size&quot;:96,&quot;mod_time&quot;:&quot;2018-06-12T15:36:29Z&quot;},
            {&quot;hash&quot;:&quot;8919df964703ccc81de5aba1b688ff1a8439b4460440a64940a11e1345e453b5&quot;,&quot;path&quot;:&quot;Swarm_files/&quot;,&quot;contentType&quot;:&quot;application/bzz-manifest+json&quot;,&quot;mod_time&quot;:&quot;0001-01-01T00:00:00Z&quot;},
            {&quot;hash&quot;:&quot;acce5ad5180764f1fb6ae832b624f1efa6c1de9b4c77b2e6ec39f627eb2fe82c&quot;,&quot;path&quot;:&quot;css/&quot;,&quot;contentType&quot;:&quot;application/bzz-manifest+json&quot;,&quot;mod_time&quot;:&quot;0001-01-01T00:00:00Z&quot;},
            {&quot;hash&quot;:&quot;0a000783e31fcf0d1b01ac7d7dae0449cf09ea41731c16dc6cd15d167030a542&quot;,&quot;path&quot;:&quot;ethersphere/orange-papers/&quot;,&quot;contentType&quot;:&quot;application/bzz-manifest+json&quot;,&quot;mod_time&quot;:&quot;0001-01-01T00:00:00Z&quot;},
            {&quot;hash&quot;:&quot;b17868f9e5a3bf94f955780e161c07b8cd95cfd0203d2d731146746f56256e56&quot;,&quot;path&quot;:&quot;f&quot;,&quot;contentType&quot;:&quot;application/bzz-manifest+json&quot;,&quot;mod_time&quot;:&quot;0001-01-01T00:00:00Z&quot;},
            {&quot;hash&quot;:&quot;977055b5f06a05a8827fb42fe6d8ec97e5d7fc5a86488814a8ce89a6a10994c3&quot;,&quot;path&quot;:&quot;i&quot;,&quot;contentType&quot;:&quot;application/bzz-manifest+json&quot;,&quot;mod_time&quot;:&quot;0001-01-01T00:00:00Z&quot;},
            {&quot;hash&quot;:&quot;48d9624942e927d660720109b32a17f8e0400d5096c6d988429b15099e199288&quot;,&quot;path&quot;:&quot;js/&quot;,&quot;contentType&quot;:&quot;application/bzz-manifest+json&quot;,&quot;mod_time&quot;:&quot;0001-01-01T00:00:00Z&quot;},
            {&quot;hash&quot;:&quot;294830cee1d3e63341e4b34e5ec00707e891c9e71f619bc60c6a89d1a93a8f81&quot;,&quot;path&quot;:&quot;talks/&quot;,&quot;contentType&quot;:&quot;application/bzz-manifest+json&quot;,&quot;mod_time&quot;:&quot;0001-01-01T00:00:00Z&quot;},
            {&quot;hash&quot;:&quot;12e1beb28d86ed828f9c38f064402e4fac9ca7b56dab9cf59103268a62a2b35f&quot;,&quot;contentType&quot;:&quot;text/html; charset=utf-8&quot;,&quot;mode&quot;:420,&quot;size&quot;:31371,&quot;mod_time&quot;:&quot;2018-06-12T15:36:29Z&quot;}
  ]}
</pre></div>
</div>
<p>Note the <code class="docutils literal notranslate"><span class="pre">path</span></code> for entry <code class="docutils literal notranslate"><span class="pre">b17868...</span></code>: It is <code class="docutils literal notranslate"><span class="pre">f</span></code>. This means, there are more than one entries for this manifest which start with an <cite>f</cite>, and all those entries will be retrieved by requesting the hash <code class="docutils literal notranslate"><span class="pre">b17868...</span></code> and through that arrive at the matching manifest entry:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ wget -O- http://localhost:8500/bzz-raw:/b17868f9e5a3bf94f955780e161c07b8cd95cfd0203d2d731146746f56256e56/

{&quot;entries&quot;:[{&quot;hash&quot;:&quot;25e7859eeb7366849f3a57bb100ff9b3582caa2021f0f55fb8fce9533b6aa810&quot;,&quot;path&quot;:&quot;avicon.ico&quot;,&quot;mode&quot;:493,&quot;size&quot;:32038,&quot;mod_time&quot;:&quot;2018-06-12T15:36:29Z&quot;},
            {&quot;hash&quot;:&quot;97cfd23f9e36ca07b02e92dc70de379a49be654c7ed20b3b6b793516c62a1a03&quot;,&quot;path&quot;:&quot;onts/glyphicons-halflings-regular.&quot;,&quot;contentType&quot;:&quot;application/bzz-manifest+json&quot;,&quot;mod_time&quot;:&quot;0001-01-01T00:00:00Z&quot;}
 ]}
</pre></div>
</div>
<p>So we can see that the <code class="docutils literal notranslate"><span class="pre">f</span></code> entry in the root hash resolves to a manifest containing <code class="docutils literal notranslate"><span class="pre">avicon.ico</span></code> and <code class="docutils literal notranslate"><span class="pre">onts/glyphicons-halflings-regular</span></code>. The latter is interesting in itself: its <code class="docutils literal notranslate"><span class="pre">content_type</span></code> is <code class="docutils literal notranslate"><span class="pre">application/bzz-manifest+json</span></code>, so it points to another manifest. Its <code class="docutils literal notranslate"><span class="pre">path</span></code> also does contain a path separator, but that does not result in a new manifest after the path separator like a directory (e.g. at <code class="docutils literal notranslate"><span class="pre">onts/</span></code>). The reason is that on the file system on the hard disk, the <code class="docutils literal notranslate"><span class="pre">fonts</span></code> directory only contains <em>one</em> directory named <code class="docutils literal notranslate"><span class="pre">glyphicons-halflings-regular</span></code>, thus creating a new manifest for just <code class="docutils literal notranslate"><span class="pre">onts/</span></code> would result in an unnecessary lookup. This general approach has been chosen to limit unnecessary lookups that would only slow down retrieval, and manifest “forks” happen in order to have the logarythmic bandwidth needed to retrieve a file in a directory with thousands of files.</p>
<p>When requesting <code class="docutils literal notranslate"><span class="pre">wget</span> <span class="pre">-O-</span> <span class="pre">&quot;http://swarm-gateways.net/bzz-raw:/theswarm.eth/favicon.ico</span></code>, Swarm will first retrieve the manifest at the root hash, match on the first <code class="docutils literal notranslate"><span class="pre">f</span></code> in the entry list, resolve the hash for that entry and finally resolve the hash for the <code class="docutils literal notranslate"><span class="pre">favicon.ico</span></code> file.</p>
<p>For the <code class="docutils literal notranslate"><span class="pre">theswarm.eth</span></code> page, the same applies to the <code class="docutils literal notranslate"><span class="pre">i</span></code> entry in the root hash manifest. If we look up that hash, we’ll find entries for <code class="docutils literal notranslate"><span class="pre">mages/</span></code> (a further manifest), and <code class="docutils literal notranslate"><span class="pre">ndex.html</span></code>, whose hash resolves to the main <code class="docutils literal notranslate"><span class="pre">index.html</span></code> for the web page.</p>
<p>Paths like <code class="docutils literal notranslate"><span class="pre">css/</span></code> or <code class="docutils literal notranslate"><span class="pre">js/</span></code> get their own manifests, just like common directories, because they contain several files.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If a request is issued which Swarm can not resolve unambiguosly, a <code class="docutils literal notranslate"><span class="pre">300</span> <span class="pre">&quot;Multiplce</span> <span class="pre">Choices&quot;</span></code> HTTP status will be returned.
In the example above, this would apply for a request for <code class="docutils literal notranslate"><span class="pre">http://swarm-gateways.net/bzz:/theswarm.eth/i</span></code>, as it could match both <code class="docutils literal notranslate"><span class="pre">images/</span></code> as well as <code class="docutils literal notranslate"><span class="pre">index.html</span></code></p>
</div>
</div>
<div class="section" id="encryption">
<span id="id6"></span><h2>5.4. Encryption<a class="headerlink" href="#encryption" title="Permalink to this headline">¶</a></h2>
<p>Introduced in POC 0.3, symmetric encryption is now readily available to be used with the <code class="docutils literal notranslate"><span class="pre">swarm</span> <span class="pre">up</span></code> upload command.
The encryption mechanism is meant to protect your information and make the chunked data unreadable to any handling Swarm node.</p>
<p>Swarm uses <a class="reference external" href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Counter_(CTR)">Counter mode encryption</a> to encrypt and decrypt content. When you upload content to Swarm, the uploaded data is split into 4 KB chunks. These chunks will all be encoded with a separate randomly generated encryption key. The encryption happens on your local Swarm node, unencrypted data is not shared with other nodes. The reference of a single chunk (and the whole content) will be the concatenation of the hash of encoded data and the decryption key. This means the reference will be longer than the standard unencrypted Swarm reference (64 bytes instead of 32 bytes).</p>
<p>When your node syncs the encrypted chunks of your content with other nodes, it does not share the full references (or the decryption keys in any way) with the other nodes. This means that other nodes will not be able to access your original data, moreover they will not be able to detect whether the synchronized chunks are encrypted or not.</p>
<p>When your data is retrieved it will only get decrypted on your local Swarm node. During the whole retrieval process the chunks traverse the network in their encrypted form, and none of the participating peers are able to decrypt them. They are only decrypted and assembled on the Swarm node you use for the download.</p>
<p>More info about how we handle encryption at Swarm can be found <a class="reference external" href="https://github.com/ethersphere/swarm/wiki/Symmetric-Encryption-for-Swarm-Content">here</a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Swarm currently supports both encrypted and unencrypted <code class="docutils literal notranslate"><span class="pre">swarm</span> <span class="pre">up</span></code> commands through usage of the <code class="docutils literal notranslate"><span class="pre">--encrypt</span></code> flag.
This might change in the future as we will refine and make Swarm a safer network.</p>
</div>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">The encryption feature is non-deterministic (due to a random key generated on every upload request) and users of the API should not rely on the result being idempotent; thus uploading the same content twice to Swarm with encryption enabled will not result in the same reference.</p>
</div>
<p>Example usage:</p>
<p>First, we create a simple test file.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ echo &quot;testfile&quot; &gt; mytest.txt
</pre></div>
</div>
<p>We upload the test file <strong>without</strong> encryption,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ swarm up mytest.txt
&gt; &lt;file reference&gt;
</pre></div>
</div>
<p>and <strong>with</strong> encryption.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ swarm up --encrypt mytest.txt
&gt; &lt;encrypted reference&gt;
</pre></div>
</div>
<p>Note that the reference of the encrypted upload is <strong>longer</strong> than that of the unencrypted upload. Note also that, because of the random encryption key, repeating the encrypted upload results in a different reference:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ swarm up --encrypt mytest.txt
&lt;another encrypted reference&gt;
</pre></div>
</div>
</div>
<div class="section" id="access-control">
<h2>5.5. Access Control<a class="headerlink" href="#access-control" title="Permalink to this headline">¶</a></h2>
<p>Swarm supports restricting access to content through several access control strategies:</p>
<ul>
<li><p class="first">Password protection - where a number of undisclosed parties can access content using a shared secret <code class="docutils literal notranslate"><span class="pre">(pass,</span> <span class="pre">act)</span></code></p>
</li>
<li><p class="first">Selective access using <a class="reference external" href="https://en.wikipedia.org/wiki/Elliptic-curve_cryptography">Elliptic Curve</a> key-pairs:</p>
<blockquote>
<div><ul class="simple">
<li>For an undisclosed party - where only one grantee can access the content <code class="docutils literal notranslate"><span class="pre">(pk)</span></code></li>
<li>For a number of undisclosed parties - where every grantee can access the content <code class="docutils literal notranslate"><span class="pre">(act)</span></code></li>
</ul>
</div></blockquote>
</li>
</ul>
<p><strong>Creating</strong> access control for content is currently supported only through CLI usage.</p>
<p><strong>Accessing</strong> restricted content is available through CLI and HTTP. When accessing content which is restricted by a password <a class="reference external" href="https://en.wikipedia.org/wiki/Basic_access_authentication">HTTP Basic access authentication</a> can be used out-of-the-box.</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">When accessing content which is restricted to certain EC keys - the node which exposes the HTTP proxy that is queried must be started with the granted private key as its <code class="docutils literal notranslate"><span class="pre">bzzaccount</span></code> CLI parameter.</p>
</div>
<div class="section" id="password-protection">
<h3>5.5.1. Password protection<a class="headerlink" href="#password-protection" title="Permalink to this headline">¶</a></h3>
<p>The simplest type of credential is a passphrase. In typical use cases, the
passphrase is distributed by off-band means, with adequate security measures.
Any user that knows the passphrase can access the content.</p>
<p>When using password protection, a given content reference (e.g.: a given Swarm manifest address or, alternatively,
a Mutable Resource address) is encrypted using <a class="reference external" href="https://en.wikipedia.org/wiki/Scrypt">scrypt</a>
with a given passphrase and a random salt.
The encrypted reference and the salt are then embedded into an unencrypted manifest which can be freely
distributed but only accessed by undisclosed parties that posses knowledge of the passphrase.</p>
<p>Password protection can also be used for selective access when using the <code class="docutils literal notranslate"><span class="pre">act</span></code> strategy - similarly to granting access to a certain EC key access can be also given to a party identified by a password. In fact, one could also create an <code class="docutils literal notranslate"><span class="pre">act</span></code> manifest that solely grants access to grantees through passwords, without the need to know their public keys.</p>
<p>Example usage:</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">Restricting access to content on Swarm is a 2-step process - you first upload your content, then wrap the reference with an access control manifest. <strong>We recommend that you always upload your content with encryption enabled</strong>. In the following examples we will refer the uploaded content hash as <code class="docutils literal notranslate"><span class="pre">reference</span> <span class="pre">hash</span></code></p>
</div>
<p>First, we create a simple test file. We upload it to Swarm (with encryption).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ echo &quot;testfile&quot; &gt; mytest.txt
$ swarm up --encrypt mytest.txt
&gt; &lt;reference hash&gt;
</pre></div>
</div>
<p>Then, for the sake of this example, we create a file with our password in it.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ echo &quot;mypassword&quot; &gt; mypassword.txt
</pre></div>
</div>
<p>This password will protect the access-controlled content that we upload. We can refer to this password using the <cite>–password</cite> flag. The password file should contain the password in plaintext.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">swarm</span> <span class="pre">access</span></code> command sets a new password using the <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">pass</span></code> argument. It expects you to input the password file and the uploaded Swarm content hash you’d like to limit access to.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ swarm access new pass --password mypassword.txt &lt;reference hash&gt;
&gt; &lt;reference of access controlled manifest&gt;
</pre></div>
</div>
<p>The returned hash is the hash of the access controlled manifest.</p>
<p>When requesting this hash through the HTTP gateway you should receive an <code class="docutils literal notranslate"><span class="pre">HTTP</span> <span class="pre">Unauthorized</span> <span class="pre">401</span></code> error:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ curl http://localhost:8500/bzz:/&lt;reference of access controlled manifest&gt;/
&gt; Code: <span class="m">401</span>
&gt; Message: cant decrypt - forbidden
&gt; Timestamp: XXX
</pre></div>
</div>
<p>You can retrieve the content in three ways:</p>
<ol class="arabic simple">
<li>The same request should make an authentication dialog pop-up in the browser. You could then input the password needed and the content should correctly appear. (Leave the username empty.)</li>
<li>Requesting the same hash with HTTP basic authentication would return the content too. <code class="docutils literal notranslate"><span class="pre">curl</span></code> needs you to input a username as well as a password, but the former can be an arbitrary string (here, it’s <code class="docutils literal notranslate"><span class="pre">x</span></code>).</li>
</ol>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ curl http://x:mypassword@localhost:8500/bzz:/&lt;reference of access controlled manifest&gt;/
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li>You can also use <code class="docutils literal notranslate"><span class="pre">swarm</span> <span class="pre">down</span></code> with the <code class="docutils literal notranslate"><span class="pre">--password</span></code> flag.</li>
</ol>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ swarm  --password mypassword.txt down bzz:/&lt;reference of access controlled manifest&gt;/ mytest2.txt
$ cat mytest2.txt
&gt; testfile
</pre></div>
</div>
</div>
<div class="section" id="selective-access-using-ec-keys">
<h3>5.5.2. Selective access using EC keys<a class="headerlink" href="#selective-access-using-ec-keys" title="Permalink to this headline">¶</a></h3>
<p>A more sophisticated type of credential is an <a class="reference external" href="https://en.wikipedia.org/wiki/Elliptic-curve_cryptography">Elliptic Curve</a>
private key, identical to those used throughout Ethereum for accessing accounts.</p>
<p>In order to obtain the content reference, an
<a class="reference external" href="https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman">Elliptic-curve Diffie–Hellman</a> <cite>(ECDH)</cite>
key agreement needs to be performed between a provided EC public key (that of the content publisher)
and the authorized key, after which the undisclosed authorized party can decrypt the reference to the
access controlled content.</p>
<p>Whether using access control to disclose content to a single party (by using the <code class="docutils literal notranslate"><span class="pre">pk</span></code> strategy) or to
multiple parties (using the <code class="docutils literal notranslate"><span class="pre">act</span></code> strategy), a third unauthorized party cannot find out the identity
of the authorized parties.
The third party can, however, know the number of undisclosed grantees to the content.
This, however, can be mitigated by adding bogus grantee keys while using the <code class="docutils literal notranslate"><span class="pre">act</span></code> strategy
in cases where masking the number of grantees is necessary. This is not the case when using the <code class="docutils literal notranslate"><span class="pre">pk</span></code> strategy, as it as
by definition an agreement between two parties and only two parties (the publisher and the grantee).</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">Accessing content which is access controlled is enabled only when using a <cite>local</cite> Swarm node (e.g. running on <cite>localhost</cite>) in order to keep
your data, passwords and encryption keys safe. This is enforced through an in-code guard.</p>
</div>
<div class="admonition danger">
<p class="first admonition-title">Danger</p>
<p class="last"><strong>NEVER (EVER!) use an external gateway to upload or download access controlled content as you will be putting your privacy at risk!
You have been fairly warned!</strong></p>
</div>
<p><strong>Protecting content with Elliptic curve keys (single grantee):</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">pk</span></code> strategy requires a <code class="docutils literal notranslate"><span class="pre">bzzaccount</span></code> to encrypt with. The most comfortable option in this case would be the same <code class="docutils literal notranslate"><span class="pre">bzzaccount</span></code> you normally start your Swarm node with - this will allow you to access your content seamlessly through that node at any given point in time.</p>
<p>Grantee public keys are expected to be in an <em>secp256 compressed</em> form - 66 characters long string (an example would be <code class="docutils literal notranslate"><span class="pre">02e6f8d5e28faaa899744972bb847b6eb805a160494690c9ee7197ae9f619181db</span></code>). Comments and other characters are not allowed.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ swarm --bzzaccount &lt;your account&gt; access new pk --grant-key &lt;your public key&gt; &lt;reference hash&gt;
&gt; &lt;reference of access controlled manifest&gt;
</pre></div>
</div>
<p>The returned hash <code class="docutils literal notranslate"><span class="pre">4b964a75ab19db960c274058695ca4ae21b8e19f03ddf1be482ba3ad3c5b9f9b</span></code> is the hash of the access controlled manifest.</p>
<p>The only way to fetch the access controlled content in this case would be to request the hash through one of the nodes that were granted access and/or posses the granted private key (and that the requesting node has been started with the appropriate <code class="docutils literal notranslate"><span class="pre">bzzaccount</span></code> that is associated with the relevant key) - either the local node that was used to upload the content or the node which was granted access through its public key.</p>
<p><strong>Protecting content with Elliptic curve keys and passwords (multiple grantees):</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">act</span></code> strategy also requires a <code class="docutils literal notranslate"><span class="pre">bzzaccount</span></code> to encrypt with. The most comfortable option in this case would be the same <code class="docutils literal notranslate"><span class="pre">bzzaccount</span></code> you normally start your Swarm node with - this will allow you to access your content seamlessly through that node at any given point in time</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">the <code class="docutils literal notranslate"><span class="pre">act</span></code> strategy expects a grantee public-key list and/or a list of permitted passwords to be communicated to the CLI. This is done using the <code class="docutils literal notranslate"><span class="pre">--grant-keys</span></code> flag and/or the <code class="docutils literal notranslate"><span class="pre">--password</span></code> flag. Grantee public keys are expected to be in an <em>secp256 compressed</em> form - 66 characters long string (e.g. <code class="docutils literal notranslate"><span class="pre">02e6f8d5e28faaa899744972bb847b6eb805a160494690c9ee7197ae9f619181db</span></code>). Each grantee should appear in a separate line. Passwords are also expected to be line-separated. Comments and other characters are not allowed.</p>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>swarm --bzzaccount 2f1cd699b0bf461dcfbf0098ad8f5587b038f0f1 access new act --grant-keys /path/to/public-keys/file --password /path/to/passwords/file  &lt;reference hash&gt;
4b964a75ab19db960c274058695ca4ae21b8e19f03ddf1be482ba3ad3c5b9f9b
</pre></div>
</div>
<p>The returned hash <code class="docutils literal notranslate"><span class="pre">4b964a75ab19db960c274058695ca4ae21b8e19f03ddf1be482ba3ad3c5b9f9b</span></code> is the hash of the access controlled manifest.</p>
<p>As with the <code class="docutils literal notranslate"><span class="pre">pk</span></code> strategy - the only way to fetch the access controlled content in this case would be to request the hash through one of the nodes that were granted access and/or posses the granted private key (and that the requesting node has been started with the appropriate <code class="docutils literal notranslate"><span class="pre">bzzaccount</span></code> that is associated with the relevant key) - either the local node that was used to upload the content or one of the nodes which were granted access through their public keys.</p>
</div>
<div class="section" id="http-usage">
<h3>5.5.3. HTTP usage<a class="headerlink" href="#http-usage" title="Permalink to this headline">¶</a></h3>
<p>Accessing restricted content on Swarm through the HTTP API is, as mentioned, limited to your local node
due to security considerations.
Whenever requesting a restricted resource without the proper credentials via the HTTP proxy, the Swarm node will respond
with an <code class="docutils literal notranslate"><span class="pre">HTTP</span> <span class="pre">401</span> <span class="pre">Unauthorized</span></code> response code.</p>
<p><em>When accessing password protected content:</em></p>
<p>When accessing a resource protected by a passphrase without the appropriate credentials the browser will
receive an <code class="docutils literal notranslate"><span class="pre">HTTP</span> <span class="pre">401</span> <span class="pre">Unauthorized</span></code> response and will show a pop-up dialog asking for a username and password.
For the sake of decrypting the content - only the password input in the dialog matters and the username field can be left blank.</p>
<p>The credentials for accessing content protected by a password can be provided in the initial request in the form of:
<code class="docutils literal notranslate"><span class="pre">http://x:&lt;password&gt;&#64;localhost:8500/bzz:/&lt;hash</span> <span class="pre">or</span> <span class="pre">ens</span> <span class="pre">name&gt;</span></code> (<code class="docutils literal notranslate"><span class="pre">curl</span></code> needs you to input a username as well as a password, but the former can be an arbitrary string (here, it’s <code class="docutils literal notranslate"><span class="pre">x</span></code>).)</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">Access controlled content should be accessed through the <code class="docutils literal notranslate"><span class="pre">bzz://</span></code> protocol</p>
</div>
<p><em>When accessing EC key protected content:</em></p>
<p>When accessing a resource protected by EC keys, the node that requests the content will try to decrypt the restricted
content reference using its <strong>own</strong> EC key which is associated with the current <cite>bzz account</cite> that
the node was started with (see the <code class="docutils literal notranslate"><span class="pre">--bzzaccount</span></code> flag). If the node’s key is granted access - the content will be
decrypted and displayed, otherwise - an <code class="docutils literal notranslate"><span class="pre">HTTP</span> <span class="pre">401</span> <span class="pre">Unauthorized</span></code> error will be returned by the node.</p>
</div>
<div class="section" id="access-control-in-the-cli-example-usage">
<h3>5.5.4. Access control in the CLI: example usage<a class="headerlink" href="#access-control-in-the-cli-example-usage" title="Permalink to this headline">¶</a></h3>
<div class="sphinx-tabs docutils container">
<div class="ui top attached tabular menu sphinx-menu docutils container">
<div class="active item sphinx-data-tab-UGFzc3dvcmRz docutils container">
<div class="docutils container">
Passwords</div>
</div>
<div class="item sphinx-data-tab-RWxsaXB0aWMgY3VydmUga2V5cw== docutils container">
<div class="docutils container">
Elliptic curve keys</div>
</div>
</div>
<div class="ui bottom attached sphinx-tab tab segment sphinx-data-tab-UGFzc3dvcmRz active docutils container">
<p>First, we create a simple test file. We upload it to Swarm using encryption.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ echo &quot;testfile&quot; &gt; mytest.txt
$ swarm up  --encrypt mytest.txt
&gt; &lt;reference hash&gt;
</pre></div>
</div>
<p>Then, we define a password file and use it to create an access-controlled manifest.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ echo &quot;mypassword&quot; &gt; mypassword.txt
$ swarm access new pass --password mypassword.txt &lt;reference hash&gt;
&gt; &lt;reference of access controlled manifest&gt;
</pre></div>
</div>
<p>We can create a passwords file with one password per line in plaintext (<code class="docutils literal notranslate"><span class="pre">password1</span></code> is probably not a very good password).</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ <span class="k">for</span> i in <span class="o">{</span><span class="m">1</span>..3<span class="o">}</span><span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> -e password<span class="nv">$i</span><span class="p">;</span> <span class="k">done</span> &gt; mypasswords.txt
$ cat mypasswords.txt
&gt; password1
&gt; password2
&gt; password3
</pre></div>
</div>
<p>Then, we point to this list while wrapping our manifest.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ swarm access new act --password mypasswords.txt &lt;reference hash&gt;
&gt; &lt;reference of access controlled manifest&gt;
</pre></div>
</div>
<p>We can access the returned manifest using any of the passwords in the password list.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ <span class="nb">echo</span> password1 &gt; password1.txt
$ swarm --password1.txt down bzz:/&lt;reference of access controlled manifest&gt;
</pre></div>
</div>
<p>We can also <cite>curl</cite> it.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ curl http://:password1@localhost:8500/bzz:/&lt;reference of access controlled manifest&gt;/
</pre></div>
</div>
</div>
<div class="ui bottom attached sphinx-tab tab segment sphinx-data-tab-RWxsaXB0aWMgY3VydmUga2V5cw== docutils container">
<ol class="arabic simple">
<li><code class="docutils literal notranslate"><span class="pre">pk</span></code> strategy</li>
</ol>
<p>First, we create a simple test file. We upload it to Swarm using encryption.</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ echo &quot;testfile&quot; &gt; mytest.txt
$ swarm up --encrypt mytest.txt
&gt; &lt;reference hash&gt;
</pre></div>
</div>
</div></blockquote>
<p>Then, we draw an EC key pair and use the public key to create the access-controlled manifest.</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ swarm access new pk --grant-key &lt;public key&gt; &lt;reference hash&gt;
&gt; &lt;reference of access controlled manifest&gt;
</pre></div>
</div>
</div></blockquote>
<p>We can retrieve the access-controlled manifest via a node that has the private key. You can add a private key using <code class="docutils literal notranslate"><span class="pre">geth</span></code> (see <a class="reference external" href="https://github.com/ethereum/go-ethereum/wiki/Managing-your-accounts">here</a>).</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ swarm --bzzaccount &lt;address of node with granted private key&gt; down bzz:/&lt;reference of access controlled manifest&gt; out.txt
$ cat out.txt
&gt; &quot;testfile&quot;
</pre></div>
</div>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><code class="docutils literal notranslate"><span class="pre">act</span></code> strategy</li>
</ol>
<p>We can also supply a list of public keys to create the access-controlled manifest.</p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ swarm access new act --grant-keys &lt;public key list&gt; &lt;reference hash&gt;
&gt; &lt;reference of access controlled manifest&gt;
</pre></div>
</div>
</div></blockquote>
<p>Again, only nodes that possess the private key will have access to the content.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ swarm --bzzaccount &lt;address of node with a granted private key&gt; down bzz:/&lt;reference of access controlled manifest&gt; out.txt
$ cat out.txt
&gt; &quot;testfile&quot;
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="fuse">
<h2>5.6. FUSE<a class="headerlink" href="#fuse" title="Permalink to this headline">¶</a></h2>
<p>Another way of interacting with Swarm is by mounting it as a local filesystem using <a class="reference external" href="https://en.wikipedia.org/wiki/Filesystem_in_Userspace">FUSE</a> (Filesystem in Userspace). There are three IPC API’s which help in doing this.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">FUSE needs to be installed on your Operating System for these commands to work. Windows is not supported by FUSE, so these command will work only in Linux, Mac OS and FreeBSD. For installation instruction for your OS, see “Installing FUSE” section below.</p>
</div>
<div class="section" id="installing-fuse">
<h3>5.6.1. Installing FUSE<a class="headerlink" href="#installing-fuse" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li>Linux (Ubuntu)</li>
</ol>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ sudo apt-get install fuse
$ sudo modprobe fuse
$ sudo chown &lt;username&gt;:&lt;groupname&gt; /etc/fuse.conf
$ sudo chown &lt;username&gt;:&lt;groupname&gt; /dev/fuse
</pre></div>
</div>
<ol class="arabic" start="2">
<li><p class="first">Mac OS</p>
<p>Either install the latest package from <a class="reference external" href="https://osxfuse.github.io/">https://osxfuse.github.io/</a> or use brew as below</p>
</li>
</ol>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ brew update
$ brew install caskroom/cask/brew-cask
$ brew cask install osxfuse
</pre></div>
</div>
</div>
<div class="section" id="cli-usage">
<h3>5.6.2. CLI Usage<a class="headerlink" href="#cli-usage" title="Permalink to this headline">¶</a></h3>
<p>The Swarm CLI now integrates commands to make FUSE usage easier and streamlined.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When using FUSE from the CLI, we assume you are running a local Swarm node on your machine. The FUSE commands attach to the running node through <cite>bzzd.ipc</cite></p>
</div>
<p>One use case to mount a Swarm hash via FUSE is a file sharing feature accessible via your local file system.
Files uploaded to Swarm are then transparently accessible via your local file system, just as if they were stored locally.</p>
<p>To mount a Swarm resource, first upload some content to Swarm using the <code class="docutils literal notranslate"><span class="pre">swarm</span> <span class="pre">up</span> <span class="pre">&lt;resource&gt;</span></code> command.
You can also upload a complete folder using <code class="docutils literal notranslate"><span class="pre">swarm</span> <span class="pre">--recursive</span> <span class="pre">up</span> <span class="pre">&lt;directory&gt;</span></code>.
Once you get the returned manifest hash, use it to mount the manifest to a mount point
(the mount point should exist on your hard drive):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ swarm fs mount &lt;manifest-hash&gt; &lt;mount-point&gt;
</pre></div>
</div>
<p>For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ swarm fs mount &lt;manifest-hash&gt; /home/user/swarmmount
</pre></div>
</div>
<p>Your running Swarm node terminal output should show something similar to the following in case the command returned successfuly:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Attempting to mount /path/to/mount/point
Serving 6e4642148d0a1ea60e36931513f3ed6daf3deb5e499dcf256fa629fbc22cf247 at /path/to/mount/point
Now serving swarm FUSE FS                manifest=6e4642148d0a1ea60e36931513f3ed6daf3deb5e499dcf256fa629fbc22cf247 mountpoint=/path/to/mount/point
</pre></div>
</div>
<p>You may get a “Fatal: had an error calling the RPC endpoint while mounting: context deadline exceeded” error if it takes too long to retrieve the content.</p>
<p>In your OS, via terminal or file browser, you now should be able to access the contents of the Swarm hash at <code class="docutils literal notranslate"><span class="pre">/path/to/mount/point</span></code>, i.e. <code class="docutils literal notranslate"><span class="pre">ls</span> <span class="pre">/home/user/swarmmount</span></code></p>
<p>Through your terminal or file browser, you can interact with your new mount as if it was a local directory. Thus you can add, remove, edit, create files and directories just as on a local directory. Every such action will interact with Swarm, taking effect on the Swarm distributed storage. Every such action also will result <strong>in a new hash</strong> for your mounted directory. If you would unmount and remount the same directory with the previous hash, your changes would seem to have been lost (effectively you are just mounting the previous version). While you change the current mount, this happens under the hood and your mount remains up-to-date.</p>
<p>To unmount a <code class="docutils literal notranslate"><span class="pre">swarmfs</span></code> mount, either use the List Mounts command below, or use a known mount point:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ swarm fs unmount &lt;mount-point&gt;
&gt; 41e422e6daf2f4b32cd59dc6a296cce2f8cce1de9f7c7172e9d0fc4c68a3987a
</pre></div>
</div>
<p>The returned hash is the latest manifest version that was mounted.
You can use this hash to remount the latest version with the most recent changes.</p>
<p>To see all existing swarmfs mount points, use the List Mounts command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ swarm fs list
</pre></div>
</div>
<p>Example Output:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Found 1 swarmfs mount(s):
0:
        Mount point: /path/to/mount/point
        Latest Manifest: 6e4642148d0a1ea60e36931513f3ed6daf3deb5e499dcf256fa629fbc22cf247
        Start Manifest: 6e4642148d0a1ea60e36931513f3ed6daf3deb5e499dcf256fa629fbc22cf247
</pre></div>
</div>
</div>
</div>
<div class="section" id="bzz-url-schemes">
<span id="id10"></span><h2>5.7. BZZ URL schemes<a class="headerlink" href="#bzz-url-schemes" title="Permalink to this headline">¶</a></h2>
<p>Swarm offers 6 distinct URL schemes:</p>
<div class="section" id="bzz">
<h3>5.7.1. bzz<a class="headerlink" href="#bzz" title="Permalink to this headline">¶</a></h3>
<p>The bzz scheme assumes that the domain part of the url points to a manifest. When retrieving the asset addressed by the URL, the manifest entries are matched against the URL path. The entry with the longest matching path is retrieved and served with the content type specified in the corresponding manifest entry.</p>
<p>Example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>GET http://localhost:8500/bzz:/2477cc8584cc61091b5cc084cdcdb45bf3c6210c263b0143f030cf7d750e894d/readme.md
</pre></div>
</div>
<p>returns a readme.md file if the manifest at the given hash address contains such an entry.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ls
readme.md
$ swarm --recursive up .
c4c81dbce3835846e47a83df549e4cad399c6a81cbf83234274b87d49f5f9020
$ curl http://localhost:8500/bzz-raw:/c4c81dbce3835846e47a83df549e4cad399c6a81cbf83234274b87d49f5f9020/readme.md
## Hello Swarm!

Swarm is awesome%
</pre></div>
</div>
<p>If the manifest does not contain an file at <code class="docutils literal notranslate"><span class="pre">readme.md</span></code> itself, but it does contain multiple entries to which the URL could be resolved, e.g. in the example above, the manifest has entries for <code class="docutils literal notranslate"><span class="pre">readme.md.1</span></code> and <code class="docutils literal notranslate"><span class="pre">readme.md.2</span></code>, the API returns an HTTP response “300 Multiple Choices”, indicating that the request could not be unambiguously resolved. A list of available entries is returned via HTTP or JSON.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ ls
readme.md.1 readme.md.2
$ swarm --recursive up .
679bde3ccb6fb911db96a0ea1586c04899c6c0cc6d3426e9ee361137b270a463
$ curl -H &quot;Accept:application/json&quot; http://localhost:8500/bzz:/679bde3ccb6fb911db96a0ea1586c04899c6c0cc6d3426e9ee361137b270a463/readme.md
{&quot;Msg&quot;:&quot;\u003ca href=&#39;/bzz:/679bde3ccb6fb911db96a0ea1586c04899c6c0cc6d3426e9ee361137b270a463/readme.md.1&#39;\u003ereadme.md.1\u003c/a\u003e\u003cbr/\u003e\u003ca href=&#39;/bzz:/679bde3ccb6fb911db96a0ea1586c04899c6c0cc6d3426e9ee361137b270a463/readme.md.2&#39;\u003ereadme.md.2\u003c/a\u003e\u003cbr/\u003e&quot;,&quot;Code&quot;:300,&quot;Timestamp&quot;:&quot;Fri, 15 Jun 2018 14:48:42 CEST&quot;,&quot;Details&quot;:&quot;&quot;}
$ curl -H &quot;Accept:application/json&quot; http://localhost:8500/bzz:/679bde3ccb6fb911db96a0ea1586c04899c6c0cc6d3426e9ee361137b270a463/readme.md | jq
{
    &quot;Msg&quot;: &quot;&lt;a href=&#39;/bzz:/679bde3ccb6fb911db96a0ea1586c04899c6c0cc6d3426e9ee361137b270a463/readme.md.1&#39;&gt;readme.md.1&lt;/a&gt;&lt;br/&gt;&lt;a href=&#39;/bzz:/679bde3ccb6fb911db96a0ea1586c04899c6c0cc6d3426e9ee361137b270a463/readme.md.2&#39;&gt;readme.md.2&lt;/a&gt;&lt;br/&gt;&quot;,
    &quot;Code&quot;: 300,
    &quot;Timestamp&quot;: &quot;Fri, 15 Jun 2018 14:49:02 CEST&quot;,
    &quot;Details&quot;: &quot;&quot;
}
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">bzz</span></code> scheme also accepts POST requests to upload content and create manifest for them in one go:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ curl -H &quot;Content-Type: text/plain&quot; --data-binary &quot;some-data&quot; http://localhost:8500/bzz:/
635d13a547d3252839e9e68ac6446b58ae974f4f59648fe063b07c248494c7b2%
$ curl http://localhost:8500/bzz:/635d13a547d3252839e9e68ac6446b58ae974f4f59648fe063b07c248494c7b2/
some-data%
$ curl -H &quot;Accept:application/json&quot; http://localhost:8500/bzz-raw:/635d13a547d3252839e9e68ac6446b58ae974f4f59648fe063b07c248494c7b2/ | jq .
{
    &quot;entries&quot;: [
        {
            &quot;hash&quot;: &quot;379f234c04ed1a18722e4c76b5029ff6e21867186c4dfc101be4f1dd9a879d98&quot;,
            &quot;contentType&quot;: &quot;text/plain&quot;,
            &quot;mode&quot;: 420,
            &quot;size&quot;: 9,
            &quot;mod_time&quot;: &quot;2018-06-15T15:46:28.835066044+02:00&quot;
        }
    ]
}
</pre></div>
</div>
</div>
<div class="section" id="bzz-raw">
<span id="id11"></span><h3>5.7.2. bzz-raw<a class="headerlink" href="#bzz-raw" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>GET http://localhost:8500/bzz-raw:/2477cc8584cc61091b5cc084cdcdb45bf3c6210c263b0143f030cf7d750e894d
</pre></div>
</div>
<p>When responding to GET requests with the bzz-raw scheme, Swarm does not assume that the hash resolves to a manifest. Instead it just serves the asset referenced by the hash directly. So if the hash actually resolves to a manifest, it returns the raw manifest content itself.</p>
<p>E.g. continuing the example in the <code class="docutils literal notranslate"><span class="pre">bzz</span></code> section above with <code class="docutils literal notranslate"><span class="pre">readme.md.1</span></code> and <code class="docutils literal notranslate"><span class="pre">readme.md.2</span></code> in the manifest:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ curl http://localhost:8500/bzz-raw:/679bde3ccb6fb911db96a0ea1586c04899c6c0cc6d3426e9ee361137b270a463/ | jq
{
    &quot;entries&quot;: [
        {
        &quot;hash&quot;: &quot;efc6d4a7d7f0846973a321d1702c0c478a20f72519516ef230b63baa3da18c22&quot;,
        &quot;path&quot;: &quot;readme.md.&quot;,
        &quot;contentType&quot;: &quot;application/bzz-manifest+json&quot;,
        &quot;mod_time&quot;: &quot;0001-01-01T00:00:00Z&quot;
        }
    ]
    }
$ curl http://localhost:8500/bzz-raw:/efc6d4a7d7f0846973a321d1702c0c478a20f72519516ef230b63baa3da18c22/ | jq
{
    &quot;entries&quot;: [
        {
            &quot;hash&quot;: &quot;d0675100bc4580a0ad890b5d6f06310c0705d4ab1e796cfa1a8c597840f9793f&quot;,
            &quot;path&quot;: &quot;1&quot;,
            &quot;mode&quot;: 420,
            &quot;size&quot;: 33,
            &quot;mod_time&quot;: &quot;2018-06-15T14:21:32+02:00&quot;
        },
        {
            &quot;hash&quot;: &quot;f97cf36ac0dd7178c098f3661cd0402fcc711ff62b67df9893d29f1db35adac6&quot;,
            &quot;path&quot;: &quot;2&quot;,
            &quot;mode&quot;: 420,
            &quot;size&quot;: 35,
            &quot;mod_time&quot;: &quot;2018-06-15T14:42:06+02:00&quot;
        }
    ]
    }
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">content_type</span></code> query parameter can be supplied to specify the MIME type you are requesting, otherwise content is served as an octet-stream per default. For instance if you have a pdf document (not the manifest wrapping it) at hash <code class="docutils literal notranslate"><span class="pre">6a182226...</span></code> then the following url will properly serve it.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>GET http://localhost:8500/bzz-raw:/6a18222637cafb4ce692fa11df886a03e6d5e63432c53cbf7846970aa3e6fdf5?content_type=application/pdf
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">bzz-raw</span></code> also supports POST requests to upload content to Swarm, the response is the hash of the uploaded content:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ curl --data-binary &quot;some-data&quot; http://localhost:8500/bzz-raw:/
379f234c04ed1a18722e4c76b5029ff6e21867186c4dfc101be4f1dd9a879d98%
$ curl http://localhost:8500/bzz-raw:/379f234c04ed1a18722e4c76b5029ff6e21867186c4dfc101be4f1dd9a879d98/
some-data%
</pre></div>
</div>
</div>
<div class="section" id="bzz-list">
<h3>5.7.3. bzz-list<a class="headerlink" href="#bzz-list" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>GET http://localhost:8500/bzz-list:/2477cc8584cc61091b5cc084cdcdb45bf3c6210c263b0143f030cf7d750e894d/path
</pre></div>
</div>
<p>Returns a list of all files contained in &lt;manifest&gt; under &lt;path&gt; grouped into common prefixes using <code class="docutils literal notranslate"><span class="pre">/</span></code> as a delimiter. If no path is supplied, all files in manifest are returned. The response is a JSON-encoded object with <code class="docutils literal notranslate"><span class="pre">common_prefixes</span></code> string field and <code class="docutils literal notranslate"><span class="pre">entries</span></code> list field.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ curl http://localhost:8500/bzz-list:/679bde3ccb6fb911db96a0ea1586c04899c6c0cc6d3426e9ee361137b270a463/ | jq
{
    &quot;entries&quot;: [
        {
            &quot;hash&quot;: &quot;d0675100bc4580a0ad890b5d6f06310c0705d4ab1e796cfa1a8c597840f9793f&quot;,
            &quot;path&quot;: &quot;readme.md.1&quot;,
            &quot;mode&quot;: 420,
            &quot;size&quot;: 33,
            &quot;mod_time&quot;: &quot;2018-06-15T14:21:32+02:00&quot;
        },
        {
            &quot;hash&quot;: &quot;f97cf36ac0dd7178c098f3661cd0402fcc711ff62b67df9893d29f1db35adac6&quot;,
            &quot;path&quot;: &quot;readme.md.2&quot;,
            &quot;mode&quot;: 420,
            &quot;size&quot;: 35,
            &quot;mod_time&quot;: &quot;2018-06-15T14:42:06+02:00&quot;
        }
    ]
    }
</pre></div>
</div>
</div>
<div class="section" id="bzz-hash">
<h3>5.7.4. bzz-hash<a class="headerlink" href="#bzz-hash" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>GET http://localhost:8500/bzz-hash:/theswarm.eth/
</pre></div>
</div>
<p>Swarm accepts GET requests for bzz-hash url scheme and responds with the hash value of the raw content, the same content returned by requests with bzz-raw scheme. Hash of the manifest is also the hash stored in ENS so bzz-hash can be used for ENS domain resolution.</p>
<p>Response content type is <em>text/plain</em>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ curl http://localhost:8500/bzz-hash:/theswarm.eth/
7a90587bfc04ac4c64aeb1a96bc84f053d3d84cefc79012c9a07dd5230dc1fa4%
</pre></div>
</div>
</div>
<div class="section" id="bzz-immutable">
<h3>5.7.5. bzz-immutable<a class="headerlink" href="#bzz-immutable" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>GET http://localhost:8500/bzz-immutable:/2477cc8584cc61091b5cc084cdcdb45bf3c6210c263b0143f030cf7d750e894d
</pre></div>
</div>
<p>The same as the generic scheme but there is no ENS domain resolution, the domain part of the path needs to be a valid hash. This is also a read-only scheme but explicit in its integrity protection. A particular bzz-immutable url will always necessarily address the exact same fixed immutable content.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ curl http://localhost:8500/bzz-immutable:/679bde3ccb6fb911db96a0ea1586c04899c6c0cc6d3426e9ee361137b270a463/readme.md.1
## Hello Swarm!

Swarm is awesome%
$ curl -H &quot;Accept:application/json&quot; http://localhost:8500/bzz-immutable:/theswarm.eth/ | jq .
{
    &quot;Msg&quot;: &quot;cannot resolve theswarm.eth: immutable address not a content hash: \&quot;theswarm.eth\&quot;&quot;,
    &quot;Code&quot;: 404,
    &quot;Timestamp&quot;: &quot;Fri, 15 Jun 2018 13:22:27 UTC&quot;,
    &quot;Details&quot;: &quot;&quot;
}
</pre></div>
</div>
</div>
<div class="section" id="bzz-resource">
<h3>5.7.6. bzz-resource<a class="headerlink" href="#bzz-resource" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">bzz-resource</span></code> allows you to receive hash pointers to content that the ENS entry resolved to at different versions</p>
<p>bzz-resource://&lt;id&gt; - get latest update
bzz-resource://&lt;id&gt;/&lt;n&gt; - get latest update on period n
bzz-resource://&lt;id&gt;/&lt;n&gt;/&lt;m&gt; - get update version m of period n
&lt;id&gt; = ens name</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="pss.html" class="btn btn-neutral float-right" title="6. PSS" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="up-and-download.html" class="btn btn-neutral" title="4. Uploading and downloading" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Ethersphere

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/sphinx_tabs/tabs.js"></script>
        <script type="text/javascript" src="_static/sphinx_tabs/semantic-ui-2.2.10/tab.min.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>